# 数据库版本管理文档

本文档介绍如何使用 Alembic 进行数据库版本管理和迁移。

## 📋 目录

1. [概述](#概述)
2. [快速开始](#快速开始)
3. [常用命令](#常用命令)
4. [迁移工作流](#迁移工作流)
5. [高级用法](#高级用法)
6. [最佳实践](#最佳实践)
7. [故障排查](#故障排查)

## 概述

### 什么是数据库版本管理？

数据库版本管理（Database Migration）是一种追踪和管理数据库结构变更的方法。它允许我们：

- 📝 记录所有数据库结构的变更历史
- 🔄 在不同环境间同步数据库结构
- ⏪ 回滚到之前的数据库版本
- 👥 团队协作时保持数据库一致性

### 为什么使用 Alembic？

- **SQLAlchemy 集成**：与我们的 ORM 完美集成
- **自动生成**：可以自动检测模型变更并生成迁移脚本
- **版本控制**：迁移脚本可以纳入 Git 版本控制
- **灵活性**：支持复杂的数据库操作

## 快速开始

### 1. 安装依赖

```bash
pip install -r requirements.txt
```

### 2. 配置数据库

确保 `config.env` 文件中配置了正确的数据库连接信息：

```env
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_USER=root
MYSQL_PASSWORD=your_password
MYSQL_DATABASE=emotional_chat
```

### 3. 初始化数据库

首次部署时，运行以下命令创建数据库并应用所有迁移：

```bash
python db_manager.py init
```

这个命令会：
1. 创建数据库（如果不存在）
2. 运行所有迁移脚本，创建所有表

## 常用命令

### 基础命令

#### 检查数据库连接

```bash
python db_manager.py check
```

输出示例：
```
✅ 数据库连接正常
数据库地址: localhost:3306
数据库名称: emotional_chat
用户名: root
```

#### 查看当前数据库版本

```bash
python db_manager.py current
```

#### 查看迁移历史

```bash
python db_manager.py history
```

### 迁移命令

#### 升级到最新版本

```bash
python db_manager.py upgrade
```

#### 升级到特定版本

```bash
python db_manager.py upgrade -r 001
```

#### 降级一个版本

```bash
python db_manager.py downgrade
```

#### 降级到特定版本

```bash
python db_manager.py downgrade -r 001
```

#### 降级到初始状态（删除所有表）

```bash
python db_manager.py downgrade -r base
```

### 创建迁移

#### 自动生成迁移脚本

当你修改了 `backend/database.py` 中的模型后，运行：

```bash
python db_manager.py revision -m "添加用户头像字段"
```

这会自动检测模型变更并生成迁移脚本。

#### 手动创建空白迁移脚本

如果需要编写自定义迁移逻辑：

```bash
python db_manager.py revision -m "自定义数据迁移" --no-autogenerate
```

### 数据库管理命令

#### 创建数据库

```bash
python db_manager.py create
```

#### 删除数据库（危险操作！）

```bash
python db_manager.py drop
```

会要求输入 `yes` 确认。

#### 重置数据库

删除并重新创建数据库（危险操作！）：

```bash
python db_manager.py reset
```

#### 标记数据库版本

将数据库标记为特定版本（不运行迁移）：

```bash
python db_manager.py stamp -r 001
```

## 迁移工作流

### 场景1：添加新字段

假设我们要给 `User` 表添加一个 `avatar` 字段。

**步骤1**：修改模型

编辑 `backend/database.py`：

```python
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String(100), unique=True, index=True)
    username = Column(String(100))
    avatar = Column(String(500))  # 新增字段
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_active = Column(Boolean, default=True)
```

**步骤2**：生成迁移脚本

```bash
python db_manager.py revision -m "add user avatar field"
```

**步骤3**：检查生成的迁移脚本

查看 `alembic/versions/` 目录下新生成的文件，确认迁移内容正确。

**步骤4**：应用迁移

```bash
python db_manager.py upgrade
```

**步骤5**：提交到版本控制

```bash
git add alembic/versions/xxx_add_user_avatar_field.py
git add backend/database.py
git commit -m "添加用户头像字段"
```

### 场景2：创建新表

**步骤1**：在 `backend/database.py` 中定义新模型

```python
class UserProfile(Base):
    """用户资料表"""
    __tablename__ = "user_profiles"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String(100), unique=True, index=True)
    bio = Column(Text)
    avatar = Column(String(500))
    created_at = Column(DateTime, default=datetime.utcnow)
```

**步骤2-5**：同场景1

### 场景3：修改字段类型

**步骤1**：修改模型

```python
# 将 rating 从 Integer 改为 Float
rating = Column(Float)  # 原来是 Integer
```

**步骤2**：生成迁移

```bash
python db_manager.py revision -m "change rating to float"
```

**步骤3**：检查并可能需要手动调整迁移脚本

特别是对于有数据的表，可能需要添加数据转换逻辑。

**步骤4-5**：同场景1

### 场景4：重命名字段

**步骤1**：使用手动迁移

```bash
python db_manager.py revision -m "rename username to display_name" --no-autogenerate
```

**步骤2**：编辑生成的迁移文件

```python
def upgrade() -> None:
    op.alter_column('users', 'username', 
                    new_column_name='display_name')

def downgrade() -> None:
    op.alter_column('users', 'display_name', 
                    new_column_name='username')
```

**步骤3**：应用迁移

```bash
python db_manager.py upgrade
```

## 高级用法

### 数据迁移

除了结构变更，有时需要迁移数据。例如，给现有用户设置默认头像：

```python
def upgrade() -> None:
    # 添加字段
    op.add_column('users', sa.Column('avatar', sa.String(500), nullable=True))
    
    # 数据迁移
    from sqlalchemy import text
    connection = op.get_bind()
    connection.execute(
        text("UPDATE users SET avatar = 'default.png' WHERE avatar IS NULL")
    )

def downgrade() -> None:
    op.drop_column('users', 'avatar')
```

### 批量操作

对于 SQLite 或某些需要批量操作的场景：

```python
def upgrade() -> None:
    with op.batch_alter_table('users') as batch_op:
        batch_op.add_column(sa.Column('avatar', sa.String(500)))
        batch_op.create_index('ix_users_avatar', ['avatar'])
```

### 条件迁移

根据数据库类型执行不同的迁移：

```python
def upgrade() -> None:
    bind = op.get_bind()
    if bind.dialect.name == 'mysql':
        op.execute("ALTER TABLE users ENGINE=InnoDB")
    elif bind.dialect.name == 'postgresql':
        op.execute("CREATE INDEX CONCURRENTLY idx_users_email ON users(email)")
```

### 多个迁移脚本管理

查看特定版本之间的差异：

```bash
# 查看从版本 a 到版本 b 的所有迁移
python db_manager.py history -r a:b
```

### 分支合并

如果团队中有多个人同时创建了迁移，可能需要合并：

```bash
# 1. 查看当前的迁移分支
python db_manager.py branches

# 2. 合并分支
python db_manager.py merge -m "merge migrations" head1 head2
```

## 最佳实践

### 1. 迁移脚本命名规范

使用描述性的名称：

```bash
# ✅ 好的命名
python db_manager.py revision -m "add_user_avatar_field"
python db_manager.py revision -m "create_user_profile_table"
python db_manager.py revision -m "add_index_to_messages"

# ❌ 不好的命名
python db_manager.py revision -m "update"
python db_manager.py revision -m "fix"
python db_manager.py revision -m "test"
```

### 2. 总是检查自动生成的迁移

自动生成的迁移可能不完美，需要人工检查：

- 确认字段类型正确
- 确认索引设置正确
- 考虑是否需要添加数据迁移逻辑
- 确认 downgrade 函数能正确回滚

### 3. 小步迭代

每次迁移只做一件事，避免一个迁移脚本包含太多变更：

```bash
# ✅ 好的做法
python db_manager.py revision -m "add_avatar_field"
python db_manager.py revision -m "add_bio_field"

# ❌ 不好的做法
python db_manager.py revision -m "add_multiple_fields_and_create_tables"
```

### 4. 测试迁移

在应用到生产环境前：

1. 在开发环境测试
2. 测试 upgrade 和 downgrade
3. 在生产环境的副本上测试

```bash
# 测试升级
python db_manager.py upgrade

# 测试降级
python db_manager.py downgrade

# 再次升级
python db_manager.py upgrade
```

### 5. 版本控制

- 总是将迁移脚本提交到 Git
- 迁移脚本和代码变更在同一个 commit
- 写清楚 commit message

### 6. 生产环境部署流程

```bash
# 1. 备份数据库
mysqldump -u root -p emotional_chat > backup_$(date +%Y%m%d_%H%M%S).sql

# 2. 拉取最新代码
git pull origin main

# 3. 更新依赖
pip install -r requirements.txt

# 4. 查看待执行的迁移
python db_manager.py history

# 5. 应用迁移
python db_manager.py upgrade

# 6. 验证
python db_manager.py current
```

### 7. 不要修改已应用的迁移

如果迁移已经应用到生产环境，不要修改它。而是创建新的迁移来修正。

### 8. 大表变更注意事项

对于大表（如 chat_messages），添加字段时考虑：

- 设置字段为 nullable
- 使用默认值
- 考虑在低峰期执行
- 必要时分批迁移数据

```python
def upgrade() -> None:
    # 添加可空字段
    op.add_column('chat_messages', 
                  sa.Column('sentiment_score', sa.Float(), nullable=True))
    
    # 分批更新数据
    connection = op.get_bind()
    batch_size = 1000
    offset = 0
    
    while True:
        result = connection.execute(
            text(f"SELECT id FROM chat_messages LIMIT {batch_size} OFFSET {offset}")
        )
        ids = [row[0] for row in result]
        if not ids:
            break
        
        # 更新这批数据
        connection.execute(
            text("UPDATE chat_messages SET sentiment_score = 0.0 WHERE id IN :ids"),
            {"ids": tuple(ids)}
        )
        offset += batch_size
```

## 故障排查

### 问题1：迁移失败

**症状**：运行 upgrade 时报错

**解决方法**：

1. 查看错误信息
2. 检查数据库连接
3. 检查迁移脚本语法
4. 如果是部分应用失败，手动修复数据库后使用 stamp 命令标记版本

```bash
# 查看当前版本
python db_manager.py current

# 手动修复数据库后，标记为已应用
python db_manager.py stamp -r xxx
```

### 问题2：版本不同步

**症状**：本地和服务器的迁移版本不一致

**解决方法**：

1. 拉取最新代码
2. 查看迁移历史确认所有迁移脚本都存在
3. 运行 upgrade

```bash
git pull
python db_manager.py history
python db_manager.py upgrade
```

### 问题3：自动生成的迁移为空

**症状**：修改了模型但生成的迁移脚本是空的

**原因**：

- 模型没有被正确导入
- 模型定义有错误
- Base.metadata 没有包含新模型

**解决方法**：

检查 `alembic/env.py` 中是否正确导入了 Base：

```python
from backend.database import Base
target_metadata = Base.metadata
```

### 问题4：字符编码问题

**症状**：中文数据无法正常保存

**解决方法**：

确保数据库使用 UTF-8 编码：

```python
# 创建数据库时指定编码
CREATE DATABASE emotional_chat 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;
```

### 问题5：无法连接数据库

**症状**：`ERROR: Access denied for user`

**解决方法**：

1. 检查 MySQL 服务是否运行
2. 检查 config.env 中的数据库配置
3. 确认用户权限

```bash
# 检查 MySQL 服务
systemctl status mysql

# 进入 MySQL
mysql -u root -p

# 查看用户权限
SHOW GRANTS FOR 'root'@'localhost';

# 授权（如果需要）
GRANT ALL PRIVILEGES ON emotional_chat.* TO 'root'@'localhost';
FLUSH PRIVILEGES;
```

## 附录

### 目录结构

```
emotional_chat/
├── alembic/                    # Alembic 配置目录
│   ├── versions/              # 迁移脚本目录
│   │   └── 001_initial_schema.py
│   ├── env.py                 # Alembic 环境配置
│   ├── script.py.mako        # 迁移脚本模板
│   └── README                 # Alembic 说明
├── alembic.ini                # Alembic 配置文件
├── db_manager.py              # 数据库管理工具
├── backend/
│   └── database.py            # 数据库模型定义
└── docs/
    └── 数据库版本管理.md      # 本文档
```

### 相关资源

- [Alembic 官方文档](https://alembic.sqlalchemy.org/)
- [SQLAlchemy 文档](https://docs.sqlalchemy.org/)
- [MySQL 文档](https://dev.mysql.com/doc/)

### 常用 SQL 命令

```sql
-- 查看所有表
SHOW TABLES;

-- 查看表结构
DESCRIBE users;

-- 查看表的创建语句
SHOW CREATE TABLE users;

-- 查看当前数据库
SELECT DATABASE();

-- 查看表的大小
SELECT 
    table_name AS 'Table',
    ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size (MB)'
FROM information_schema.TABLES
WHERE table_schema = 'emotional_chat'
ORDER BY (data_length + index_length) DESC;
```

## 联系支持

如有问题，请：

1. 查看本文档的故障排查部分
2. 查看日志文件
3. 联系开发团队

---

**最后更新**: 2025-10-14  
**版本**: 1.0.0

